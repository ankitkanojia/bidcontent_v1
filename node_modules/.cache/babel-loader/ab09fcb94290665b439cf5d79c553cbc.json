{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert');\n\nvar signals = require('./signals.js');\n\nvar EE = require('events');\n/* istanbul ignore if */\n\n\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter;\n}\n\nvar emitter;\n\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__;\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE();\n  emitter.count = 0;\n  emitter.emitted = {};\n} // Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\n\n\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity);\n  emitter.infinite = true;\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n\n  if (loaded === false) {\n    load();\n  }\n\n  var ev = 'exit';\n\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit';\n  }\n\n  var remove = function remove() {\n    emitter.removeListener(ev, cb);\n\n    if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n      unload();\n    }\n  };\n\n  emitter.on(ev, cb);\n  return remove;\n};\n\nmodule.exports.unload = unload;\n\nfunction unload() {\n  if (!loaded) {\n    return;\n  }\n\n  loaded = false;\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig]);\n    } catch (er) {}\n  });\n  process.emit = originalProcessEmit;\n  process.reallyExit = originalProcessReallyExit;\n  emitter.count -= 1;\n}\n\nfunction emit(event, code, signal) {\n  if (emitter.emitted[event]) {\n    return;\n  }\n\n  emitter.emitted[event] = true;\n  emitter.emit(event, code, signal);\n} // { <signal>: <listener fn>, ... }\n\n\nvar sigListeners = {};\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener() {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig);\n\n    if (listeners.length === emitter.count) {\n      unload();\n      emit('exit', null, sig);\n      /* istanbul ignore next */\n\n      emit('afterexit', null, sig);\n      /* istanbul ignore next */\n\n      process.kill(process.pid, sig);\n    }\n  };\n});\n\nmodule.exports.signals = function () {\n  return signals;\n};\n\nmodule.exports.load = load;\nvar loaded = false;\n\nfunction load() {\n  if (loaded) {\n    return;\n  }\n\n  loaded = true; // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n\n  emitter.count += 1;\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig]);\n      return true;\n    } catch (er) {\n      return false;\n    }\n  });\n  process.emit = processEmit;\n  process.reallyExit = processReallyExit;\n}\n\nvar originalProcessReallyExit = process.reallyExit;\n\nfunction processReallyExit(code) {\n  process.exitCode = code || 0;\n  emit('exit', process.exitCode, null);\n  /* istanbul ignore next */\n\n  emit('afterexit', process.exitCode, null);\n  /* istanbul ignore next */\n\n  originalProcessReallyExit.call(process, process.exitCode);\n}\n\nvar originalProcessEmit = process.emit;\n\nfunction processEmit(ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg;\n    }\n\n    var ret = originalProcessEmit.apply(this, arguments);\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n\n    emit('afterexit', process.exitCode, null);\n    return ret;\n  } else {\n    return originalProcessEmit.apply(this, arguments);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}