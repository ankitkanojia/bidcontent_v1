{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar childProcess = require('child_process');\n\nvar crossSpawn = require('cross-spawn');\n\nvar stripEof = require('strip-eof');\n\nvar npmRunPath = require('npm-run-path');\n\nvar isStream = require('is-stream');\n\nvar _getStream = require('get-stream');\n\nvar pFinally = require('p-finally');\n\nvar onExit = require('signal-exit');\n\nvar errname = require('./lib/errname');\n\nvar stdio = require('./lib/stdio');\n\nvar TEN_MEGABYTES = 1000 * 1000 * 10;\n\nfunction handleArgs(cmd, args, opts) {\n  var parsed;\n  opts = Object.assign({\n    extendEnv: true,\n    env: {}\n  }, opts);\n\n  if (opts.extendEnv) {\n    opts.env = Object.assign({}, process.env, opts.env);\n  }\n\n  if (opts.__winShell === true) {\n    delete opts.__winShell;\n    parsed = {\n      command: cmd,\n      args: args,\n      options: opts,\n      file: cmd,\n      original: {\n        cmd: cmd,\n        args: args\n      }\n    };\n  } else {\n    parsed = crossSpawn._parse(cmd, args, opts);\n  }\n\n  opts = Object.assign({\n    maxBuffer: TEN_MEGABYTES,\n    buffer: true,\n    stripEof: true,\n    preferLocal: true,\n    localDir: parsed.options.cwd || process.cwd(),\n    encoding: 'utf8',\n    reject: true,\n    cleanup: true\n  }, parsed.options);\n  opts.stdio = stdio(opts);\n\n  if (opts.preferLocal) {\n    opts.env = npmRunPath.env(Object.assign({}, opts, {\n      cwd: opts.localDir\n    }));\n  }\n\n  if (opts.detached) {\n    // #115\n    opts.cleanup = false;\n  }\n\n  if (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {\n    // #116\n    parsed.args.unshift('/q');\n  }\n\n  return {\n    cmd: parsed.command,\n    args: parsed.args,\n    opts: opts,\n    parsed: parsed\n  };\n}\n\nfunction handleInput(spawned, input) {\n  if (input === null || input === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}\n\nfunction handleOutput(opts, val) {\n  if (val && opts.stripEof) {\n    val = stripEof(val);\n  }\n\n  return val;\n}\n\nfunction handleShell(fn, cmd, opts) {\n  var file = '/bin/sh';\n  var args = ['-c', cmd];\n  opts = Object.assign({}, opts);\n\n  if (process.platform === 'win32') {\n    opts.__winShell = true;\n    file = process.env.comspec || 'cmd.exe';\n    args = ['/s', '/c', \"\\\"\".concat(cmd, \"\\\"\")];\n    opts.windowsVerbatimArguments = true;\n  }\n\n  if (opts.shell) {\n    file = opts.shell;\n    delete opts.shell;\n  }\n\n  return fn(file, args, opts);\n}\n\nfunction getStream(process, stream, _ref) {\n  var encoding = _ref.encoding,\n      buffer = _ref.buffer,\n      maxBuffer = _ref.maxBuffer;\n\n  if (!process[stream]) {\n    return null;\n  }\n\n  var ret;\n\n  if (!buffer) {\n    // TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10\n    ret = new Promise(function (resolve, reject) {\n      process[stream].once('end', resolve).once('error', reject);\n    });\n  } else if (encoding) {\n    ret = _getStream(process[stream], {\n      encoding: encoding,\n      maxBuffer: maxBuffer\n    });\n  } else {\n    ret = _getStream.buffer(process[stream], {\n      maxBuffer: maxBuffer\n    });\n  }\n\n  return ret.catch(function (err) {\n    err.stream = stream;\n    err.message = \"\".concat(stream, \" \").concat(err.message);\n    throw err;\n  });\n}\n\nfunction makeError(result, options) {\n  var stdout = result.stdout,\n      stderr = result.stderr;\n  var err = result.error;\n  var code = result.code,\n      signal = result.signal;\n  var parsed = options.parsed,\n      joinedCmd = options.joinedCmd;\n  var timedOut = options.timedOut || false;\n\n  if (!err) {\n    var output = '';\n\n    if (Array.isArray(parsed.opts.stdio)) {\n      if (parsed.opts.stdio[2] !== 'inherit') {\n        output += output.length > 0 ? stderr : \"\\n\".concat(stderr);\n      }\n\n      if (parsed.opts.stdio[1] !== 'inherit') {\n        output += \"\\n\".concat(stdout);\n      }\n    } else if (parsed.opts.stdio !== 'inherit') {\n      output = \"\\n\".concat(stderr).concat(stdout);\n    }\n\n    err = new Error(\"Command failed: \".concat(joinedCmd).concat(output));\n    err.code = code < 0 ? errname(code) : code;\n  }\n\n  err.stdout = stdout;\n  err.stderr = stderr;\n  err.failed = true;\n  err.signal = signal || null;\n  err.cmd = joinedCmd;\n  err.timedOut = timedOut;\n  return err;\n}\n\nfunction joinCmd(cmd, args) {\n  var joinedCmd = cmd;\n\n  if (Array.isArray(args) && args.length > 0) {\n    joinedCmd += ' ' + args.join(' ');\n  }\n\n  return joinedCmd;\n}\n\nmodule.exports = function (cmd, args, opts) {\n  var parsed = handleArgs(cmd, args, opts);\n  var _parsed$opts = parsed.opts,\n      encoding = _parsed$opts.encoding,\n      buffer = _parsed$opts.buffer,\n      maxBuffer = _parsed$opts.maxBuffer;\n  var joinedCmd = joinCmd(cmd, args);\n  var spawned;\n\n  try {\n    spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n\n  var removeExitHandler;\n\n  if (parsed.opts.cleanup) {\n    removeExitHandler = onExit(function () {\n      spawned.kill();\n    });\n  }\n\n  var timeoutId = null;\n  var timedOut = false;\n\n  var cleanup = function cleanup() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (removeExitHandler) {\n      removeExitHandler();\n    }\n  };\n\n  if (parsed.opts.timeout > 0) {\n    timeoutId = setTimeout(function () {\n      timeoutId = null;\n      timedOut = true;\n      spawned.kill(parsed.opts.killSignal);\n    }, parsed.opts.timeout);\n  }\n\n  var processDone = new Promise(function (resolve) {\n    spawned.on('exit', function (code, signal) {\n      cleanup();\n      resolve({\n        code: code,\n        signal: signal\n      });\n    });\n    spawned.on('error', function (err) {\n      cleanup();\n      resolve({\n        error: err\n      });\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on('error', function (err) {\n        cleanup();\n        resolve({\n          error: err\n        });\n      });\n    }\n  });\n\n  function destroy() {\n    if (spawned.stdout) {\n      spawned.stdout.destroy();\n    }\n\n    if (spawned.stderr) {\n      spawned.stderr.destroy();\n    }\n  }\n\n  var handlePromise = function handlePromise() {\n    return pFinally(Promise.all([processDone, getStream(spawned, 'stdout', {\n      encoding: encoding,\n      buffer: buffer,\n      maxBuffer: maxBuffer\n    }), getStream(spawned, 'stderr', {\n      encoding: encoding,\n      buffer: buffer,\n      maxBuffer: maxBuffer\n    })]).then(function (arr) {\n      var result = arr[0];\n      result.stdout = arr[1];\n      result.stderr = arr[2];\n\n      if (result.error || result.code !== 0 || result.signal !== null) {\n        var err = makeError(result, {\n          joinedCmd: joinedCmd,\n          parsed: parsed,\n          timedOut: timedOut\n        }); // TODO: missing some timeout logic for killed\n        // https://github.com/nodejs/node/blob/master/lib/child_process.js#L203\n        // err.killed = spawned.killed || killed;\n\n        err.killed = err.killed || spawned.killed;\n\n        if (!parsed.opts.reject) {\n          return err;\n        }\n\n        throw err;\n      }\n\n      return {\n        stdout: handleOutput(parsed.opts, result.stdout),\n        stderr: handleOutput(parsed.opts, result.stderr),\n        code: 0,\n        failed: false,\n        killed: false,\n        signal: null,\n        cmd: joinedCmd,\n        timedOut: false\n      };\n    }), destroy);\n  };\n\n  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n  handleInput(spawned, parsed.opts.input);\n\n  spawned.then = function (onfulfilled, onrejected) {\n    return handlePromise().then(onfulfilled, onrejected);\n  };\n\n  spawned.catch = function (onrejected) {\n    return handlePromise().catch(onrejected);\n  };\n\n  return spawned;\n}; // TODO: set `stderr: 'ignore'` when that option is implemented\n\n\nmodule.exports.stdout = function () {\n  var _module;\n\n  return (_module = module).exports.apply(_module, arguments).then(function (x) {\n    return x.stdout;\n  });\n}; // TODO: set `stdout: 'ignore'` when that option is implemented\n\n\nmodule.exports.stderr = function () {\n  var _module2;\n\n  return (_module2 = module).exports.apply(_module2, arguments).then(function (x) {\n    return x.stderr;\n  });\n};\n\nmodule.exports.shell = function (cmd, opts) {\n  return handleShell(module.exports, cmd, opts);\n};\n\nmodule.exports.sync = function (cmd, args, opts) {\n  var parsed = handleArgs(cmd, args, opts);\n  var joinedCmd = joinCmd(cmd, args);\n\n  if (isStream(parsed.opts.input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n\n  var result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);\n  result.code = result.status;\n\n  if (result.error || result.status !== 0 || result.signal !== null) {\n    var err = makeError(result, {\n      joinedCmd: joinedCmd,\n      parsed: parsed\n    });\n\n    if (!parsed.opts.reject) {\n      return err;\n    }\n\n    throw err;\n  }\n\n  return {\n    stdout: handleOutput(parsed.opts, result.stdout),\n    stderr: handleOutput(parsed.opts, result.stderr),\n    code: 0,\n    failed: false,\n    signal: null,\n    cmd: joinedCmd,\n    timedOut: false\n  };\n};\n\nmodule.exports.shellSync = function (cmd, opts) {\n  return handleShell(module.exports.sync, cmd, opts);\n};","map":null,"metadata":{},"sourceType":"script"}