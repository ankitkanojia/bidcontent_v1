{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar niceTry = require('nice-try');\n\nvar resolveCommand = require('./util/resolveCommand');\n\nvar escape = require('./util/escape');\n\nvar readShebang = require('./util/readShebang');\n\nvar semver = require('semver');\n\nvar isWin = process.platform === 'win32';\nvar isExecutableRegExp = /\\.(?:com|exe)$/i;\nvar isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i; // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\n\nvar supportsShellOption = niceTry(function () {\n  return semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true);\n}) || false;\n\nfunction detectShebang(parsed) {\n  parsed.file = resolveCommand(parsed);\n  var shebang = parsed.file && readShebang(parsed.file);\n\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    return resolveCommand(parsed);\n  }\n\n  return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n  if (!isWin) {\n    return parsed;\n  } // Detect & add support for shebangs\n\n\n  var commandFile = detectShebang(parsed); // We don't need a shell if the command filename is an executable\n\n  var needsShell = !isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  // Note that `forceShell` is an hidden option used only in tests\n\n  if (parsed.options.forceShell || needsShell) {\n    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n    // we need to double escape them\n    var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n    // This is necessary otherwise it will always fail with ENOENT in those cases\n\n    parsed.command = path.normalize(parsed.command); // Escape command & arguments\n\n    parsed.command = escape.command(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escape.argument(arg, needsDoubleEscapeMetaChars);\n    });\n    var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\n\nfunction parseShell(parsed) {\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  } // Mimic node shell option\n  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n\n\n  var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n\n    parsed.args = ['-c', shellCommand];\n  }\n\n  return parsed;\n}\n\nfunction parse(command, args, options) {\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = Object.assign({}, options); // Clone object to avoid changing the original\n  // Build our parsed object\n\n  var parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: {\n      command: command,\n      args: args\n    }\n  }; // Delegate further parsing to shell or non-shell\n\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}