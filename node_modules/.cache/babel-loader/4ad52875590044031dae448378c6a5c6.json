{"ast":null,"code":"module.exports = which;\nwhich.sync = whichSync;\nvar isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';\n\nvar path = require('path');\n\nvar COLON = isWindows ? ';' : ':';\n\nvar isexe = require('isexe');\n\nfunction getNotFoundError(cmd) {\n  var er = new Error('not found: ' + cmd);\n  er.code = 'ENOENT';\n  return er;\n}\n\nfunction getPathInfo(cmd, opt) {\n  var colon = opt.colon || COLON;\n  var pathEnv = opt.path || process.env.PATH || '';\n  var pathExt = [''];\n  pathEnv = pathEnv.split(colon);\n  var pathExtExe = '';\n\n  if (isWindows) {\n    pathEnv.unshift(process.cwd());\n    pathExtExe = opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM';\n    pathExt = pathExtExe.split(colon); // Always test the cmd itself first.  isexe will check to make sure\n    // it's found in the pathExt set.\n\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');\n  } // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n\n\n  if (cmd.match(/\\//) || isWindows && cmd.match(/\\\\/)) pathEnv = [''];\n  return {\n    env: pathEnv,\n    ext: pathExt,\n    extExe: pathExtExe\n  };\n}\n\nfunction which(cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt;\n    opt = {};\n  }\n\n  var info = getPathInfo(cmd, opt);\n  var pathEnv = info.env;\n  var pathExt = info.ext;\n  var pathExtExe = info.extExe;\n  var found = [];\n\n  (function F(i, l) {\n    if (i === l) {\n      if (opt.all && found.length) return cb(null, found);else return cb(getNotFoundError(cmd));\n    }\n\n    var pathPart = pathEnv[i];\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"') pathPart = pathPart.slice(1, -1);\n    var p = path.join(pathPart, cmd);\n\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p;\n    }\n\n    ;\n\n    (function E(ii, ll) {\n      if (ii === ll) return F(i + 1, l);\n      var ext = pathExt[ii];\n      isexe(p + ext, {\n        pathExt: pathExtExe\n      }, function (er, is) {\n        if (!er && is) {\n          if (opt.all) found.push(p + ext);else return cb(null, p + ext);\n        }\n\n        return E(ii + 1, ll);\n      });\n    })(0, pathExt.length);\n  })(0, pathEnv.length);\n}\n\nfunction whichSync(cmd, opt) {\n  opt = opt || {};\n  var info = getPathInfo(cmd, opt);\n  var pathEnv = info.env;\n  var pathExt = info.ext;\n  var pathExtExe = info.extExe;\n  var found = [];\n\n  for (var i = 0, l = pathEnv.length; i < l; i++) {\n    var pathPart = pathEnv[i];\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"') pathPart = pathPart.slice(1, -1);\n    var p = path.join(pathPart, cmd);\n\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p;\n    }\n\n    for (var j = 0, ll = pathExt.length; j < ll; j++) {\n      var cur = p + pathExt[j];\n      var is;\n\n      try {\n        is = isexe.sync(cur, {\n          pathExt: pathExtExe\n        });\n\n        if (is) {\n          if (opt.all) found.push(cur);else return cur;\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length) return found;\n  if (opt.nothrow) return null;\n  throw getNotFoundError(cmd);\n}","map":null,"metadata":{},"sourceType":"script"}